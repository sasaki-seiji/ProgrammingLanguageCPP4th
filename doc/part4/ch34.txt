【34.4.4:　scoped_allocator_adaptorに適用するためのアロケータの要件】

日付：　2016.12.11、2016.12.12
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
参考：
	Allocatorの要件については、
		http://en.cppreference.com/w/cpp/concept/Allocator
	を参照

コメント：

	scoped_alloctor_adaptorの内部・外部アロケータに適用するためには以下が必要
	①デフォルトコンストラクタを実装する
	②==により比較ができる
	③consturctメンバ関数で完全転送を使用しない
	（コンパイラが無限ループに入る模様）

	My_allocクラスでは、①のために、Areanを参照でなくポインタとして
	保持するように変更

	template<typename T>
	struct My_alloc {
		// 2016.12.11 change:
		//	scoped_allocator_adaptor needs default constructor,
		//	reference a -> pointer pa
		Arena* pa;
		My_alloc(Arena& aa) : pa(&aa) { }
		My_alloc() : pa{nullptr} { }

		using value_type = T;
		template<typename U>
			struct rebind { using other = My_alloc<U>; };

		// 2016.12.11 add: My_alloc<List> instance -> My_alloc<Link> instance
		template<typename U>
			My_alloc(const My_alloc<U>& alloc) : pa{alloc.pa} { }
	
		T* allocate(size_t n)
			{ return reinterpret_cast<T*>(pa->get(n*sizeof(T))); }
		void deallocate(T* p, size_t n)
			{ pa->release(p, n*sizeof(T)); }

		template<typename U, typename... Args>
			// 2016.12.11 change: compiler into infinite recursion
	#if 0
			void construct(U* p, Args&&... args)
				{ new(p) T{std::forward<Args>(args)...}; }
				// [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]
	#else
			void construct(U* p, Args... args)
				{ new(p) T{args...}; }
	#endif
		template<typename U>
			void destroy(U* p) { p->~U(); }

		// 2016.12.11 add for scoped_allocator_adaptor
		bool operator==(const My_alloc<T>& other) const { return pa == other.pa; }
	};

