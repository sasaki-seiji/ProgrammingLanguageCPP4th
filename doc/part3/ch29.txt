【29.2.1:　Matrix_refからMatrixを構築および代入するコードのバグ】

日付：　2016.11.12
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

・テキストのMatrix_refからMatrixを構築するコードには、以下の問題がある
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>::Matrix(const Matrix_ref<U,N>& x)
			:desc{x.desc}, elems{x.begin(),x.end()}
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");
		}

	①x.descはMatrix_refのprivateメンバのため、Matrixからアクセスできない
	②Matrix_refは要素が連続配置されていないため、desc(Matrix_slice)を
	　単純にコピーできない（新規に作成されるMatrixは要素を連続的に配置する）
	　
	この問題を対策するため、以下のように変更した
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>::Matrix(const Matrix_ref<U,N>& x)
		// 2016.11.08, 2016.11.12 change
			//:desc{x.desc}, elems{x.begin(),x.end()}
			:desc{x.descriptor()}, elems(x.begin(),x.end())
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			// 2016.11.12 add
			desc.start = 0;
			desc.extents = x.descriptor().extents;
			Matrix_impl::compute_strides(desc);
		}

・Matrix_refをMatrixに代入する処理にも同様な問題がある
	以下のように変更
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>& Matrix<T,N>::operator=(const Matrix_ref<U,N>& x)
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			desc = x.desc;
			elems.assign(x.begin(),x.end());
			return *this;
		}

		↓
		
	// Matrix: assign Matrix_ref
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>& Matrix<T,N>::operator=(const Matrix_ref<U,N>& x)
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			std::vector<T> nv{x.begin(), x.end()};	// exception safe

			desc.start = 0;
			desc.extents = x.descriptor().extents;
			Matrix_impl::compute_strides(desc);
			elems = nv;
			return *this;
		}



【29.2.1:　Matrix_refの反復子の追加】

日付：　2016.11.12
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrix_refからMatrixを構築、及び、Matrix_refをMatrixに代入する際に
	Matrix_refに反復子の処理を提供する必要がある。
	
	以下のように実現：
	
	①Matrix_refの反復子クラスを提要
		const用（Matrix_ref_const_iterator）と、非const用（Matrix_ref_iterator）の2つのクラスを定義
		
	②Matrixクラスに、反復子を返すbegin()と、end()を追加
		const用と、非const用のそれぞれ1つずつ

	①の反復子クラスは以下のように定義（const用の反復子も同様）
		
		template<typename T, size_t N>
		class Matrix_ref_iterator : public std::iterator<std::input_iterator_tag, T>
		{
		public:
			bool operator==(const Matrix_ref_iterator& other) const ;
			bool operator!=(const Matrix_ref_iterator& other) const
				{ return !(*this == other); }
			Matrix_ref_iterator& operator++();
			T& operator*();

			static Matrix_ref_iterator begin(Matrix_ref<T,N>* ref);
			static Matrix_ref_iterator end(Matrix_ref<T,N>* ref);

		private:
			Matrix_ref_iterator(Matrix_ref<T,N>* ref);

			Matrix_ref<T,N> *ref;
			std::array<size_t, N> cur;
		};

	ここで、反復子は、反復対象のMatrix_refへのポインタ(ref)と、
	今どこを反復しているかを示すarray型のインデックス（cur）を
	データメンバとして保持する。
	
	begin()に対応するインデックスは、(0,0,...0)であり、end()のインデックスは、
	(extents[0],0,...0)である。
	
	反復子の前進操作は、最下位のインデックス値から順次インクリメントする
	そして、もし終端に到達した、終端を示すインデックス値に設定する
	
		template<typename T, size_t N>
		Matrix_ref_iterator<T,N>& Matrix_ref_iterator<T,N>::operator++()
		{
			int i = N-1;
			while (i >= 0) {
				++cur[i];
				if (cur[i] < ref->extent(i)) return *this;
				cur[i] = 0;
				--i;
			}

			// reach to end
			cur[0] = ref->extent(0);
			return *this;
		}

	反復子の参照外し(*)は、インデックスから要素にアクセスするように、
	Matrix_refに依頼（Matrix_refに対応するメソッドを追加）
	
		template<typename T, size_t N>
		T& Matrix_ref_iterator<T,N>::operator*()
		{
			return ref->at(cur);
		}

	②反復子に関連するMatrix_refのメンバは以下のように定義

		template<typename T, size_t N>
		class Matrix_ref {
		public:
				・・・
			using iterator = Matrix_ref_iterator<T,N>;
			using const_iterator = Matrix_ref_const_iterator<T,N>;
				・・・
			iterator begin() { return iterator::begin(this); }
			const_iterator begin() const { return const_iterator::begin(this); }
			iterator end() { return iterator::end(this); }
			const_iterator end() const { return const_iterator::end(this); }
				・・・
			T& at(std::array<size_t,N>& i) { return *(ptr + desc.at(i)); }
			const T& at(std::array<size_t,N>& i) const 	{ return *(ptr + desc.at(i)); }

		private:
			Matrix_slice<N> desc;
			T* ptr;
		};

【29.2.2:　Matrix_initializerからMatrix_refへの代入演算が必要】

日付：　2016.11.10、2016.11.20
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	29.2.2「添え字演算とスライシング」　の例題
	
		Matrix<int,2> m2 {
			{01,02,03},
			{11,12,13},
			{21,22,23}
		};
		m2(slice{1,2},slice{0,3}) = {
				{111,112,113},
				{121,122,123}
		};
	
	にて、m2(slice{1,2},slice{0,3})は、Matrix_ref<int,2>であり、代入の右辺は
	Matrix_initializer<int,2>である
	
	以下のようにして代入演算子を実装する
		
		template<typename T, size_t N>
		Matrix_ref<T,N>& Matrix_ref<T,N>::operator=(Matrix_initializer<T,N> init)
		{
			std::array<size_t, N> extents = Matrix_impl::derive_extents<N>(init);
			assert(extents == desc.extents);

			iterator it = begin();
			Matrix_impl::copy_flat(init, it);

			return *this;
		}
		
	ここではまず、Matrix_impl::derive_extents<N>(init)を呼び出して、代入元の
	Matrix_initializerが正しいフォーマットを持っているかを確認する。
	そして、Matrix_impl::copy_flat(init, it)を呼び出し、Matrix_initializerの
	各要素を、Matrix_refの要素としてコピーする
	
	copy_flatは以下のようにして実装する
	
		template<typename T, typename Iter>
		void copy_flat(std::initializer_list<T> init, Iter& it)
		{
			for (auto& elem : init)
			copy_flat(elem, it);
		}

	copy_flatは、Matrix_initializerをinitializer_lilstとして受け取り、
	その各要素に対して、より低次元のcopy_flatを呼び出す。
	そして、initializer_listではない末端の要素に到達すると、
	以下のテンプレート多重関数が呼び出される
	
		template<typename T, typename Iter>
		void copy_flat(const T& v, Iter& it)
		{
			*it = v;
			++it;
		}

	ここでは各要素を反復子が指す位置に代入してから、反復子をインクリメントする。
	反復子は、Matrix_refが用意した反復子であり、ストライド計算を適切に行う	


【29.3.2:　Matrixの混合演算の関数テンプレート宣言の誤り】

日付：　2016.11.11、2016.11.18
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrixの混合演算関数テンプレート関数の宣言に誤りがある

		typename RT = Matrix<Common_type<Value_type<T>,Value_type<T2>>,N>>
	の箇所は、
		typename RT = Common_type<T,T2>>
	でなければならない
	
		template<typename T, typename T2, size_t N,
			//typename RT = Matrix<Common_type<Value_type<T>,Value_type<T2>>,N>>
			typename RT = Common_type<T,T2>>
		Matrix<RT,N> operator+(const Matrix<T,N>& a, const Matrix<T2,N>& b)
		{
			Matrix<RT,N> res = a;
			res+=b;
			return res;
		}

【29.3.2:　Matrixの混合演算実現のため、他の型のMatrixからのコンストラクタが必要】

日付：　2016.11.11、2016.11.20
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrixの混合演算を実現するため、他の型を要素とするMatrixを引数とする
	Matrixのコンストラクタが必要となる。
	
	以下の混合演算において、Matrix<RT,N> res = a;　の行が該当する

	
		template<typename T, typename T2, size_t N,
			typename RT = Common_type<T,T2>>
		Matrix<RT,N> operator+(const Matrix<T,N>& a, const Matrix<T2,N>& b)
		{
			Matrix<RT,N> res = a;
			res+=b;
			return res;
		}

	Matrixクラスに以下のメンバを追加
	
		// 2016.11.11 add
		template<typename U>
			Matrix(const Matrix<U,N>&);
		template<typename U>
			Matrix& operator=(const Matrix<U,N>&);


【29.4.5:　Matrix::rowテンプレート関数の部分特殊化】

日付：　2016.11.06、2016.11.22
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テンプレート関数の部分特殊化は文法上許されていない。
	そのため、Matrix::row<T,1>は以下のエラーが出力されて、コンパイルされない
	
		template<typename T>
		T& Matrix<T,1>::row(size_t i)
		{
			return elem[i];
		}
			↓
		error: invalid use of incomplete type 'class Matrix<T, 1ull>'
 		T& Matrix<T,1>::row(size_t i)

	ここでは、Matrix_ref<T,0>の特殊化されたテンプレートクラスを定義することで
	Matrix_ref<N-1,T>& Matrix<T,N>::row(size_t)　がN=1の時にも対応可能とする
	
		// Matrix<T,N>の行を参照するMatrix_ref<N-1,T>を返す
		template<typename T, size_t N>
		Matrix_ref<T,N-1> Matrix<T,N>::row(size_t n)
		{
			assert(n<rows());
			Matrix_slice<N-1> row;
			Matrix_impl::slice_dim<0>(n,desc,row);
			return {row,data()};
		}

		// Matrix_ref<T,N> の　N=0 の時の特殊化
		//	Matrix<T,1>::row(size_t),　Matrix_ref<T,1>::row(size_t)のリターン値となる
		template<typename T>
		class Matrix_ref<T,0>
		{
		public:
			//static constexpr size_t order = 0;
			using value_type = T;

			Matrix_ref(const Matrix_slice<0>& s, T* p) :desc{s}, ptr{p} { }

			T& operator()() { return *(ptr + desc()); }
			const T& operator()() const { return *(ptr + desc()); }

			operator T&() { return *(ptr + desc()); }
			operator const T&() const { return *(ptr + desc()); }

			Matrix_ref& operator=(const T& v) { *(ptr + desc()) = v; return *this; }

		private:
			Matrix_slice<0> desc;
			T* ptr;
		};

	ここで、Matrix_ref<T,0>::descは、startが正しいオフセット、sizeが1、
	extentsとstridesが空の(size()が0）のstd::arrayとなるように
	Matrix_impl::slice_dim<0>(n,desc,row)　が計算する（自然とそうなる）
	
	
【29.4.5:　Matrix_impl::check_bounds のバグ】

日付：　2016.11.06、2016.11.22
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrix_impl::check_boundsには以下の問題がある
	
	①可変長引数のサイズチェックが抜けている
	②std::equalは組み込み配列型に対して適用できない(エラーが出る)

	以下のように修正

		template<size_t N, typename... Dims>
		bool check_bounds(const Matrix_slice<N>& slice, Dims... dims)
		{
			// 2016.11.05 add
			static_assert(sizeof...(Dims)==N, "check_bounds(): dimension mismatch");

			size_t indexes[N] {size_t(dims)...};
		#if 0	// 2016.11.06 change
			return std::equal(indexes. indexes+N, slice.extents.begin(), std::less<size_t>{});
				// error: request for member 'indexes' in 'indexes', which is of non-class type 'std::size_t [2] {aka long long unsigned int [2]}'
		#else
			for (size_t i = 0; i < N; ++i)
				if (indexes[i] >= slice.extents[i]){
					std::cerr << "Matrix_impl::check_bounds : out of range - indexes[" << i << "]=" << indexes[i] << std::endl << std::flush;
					return false;
				}
			return true;
		#endif
		}

