【29.2.1:　Matrix_refからMatrixを構築および代入するコードのバグ】

日付：　2016.11.12
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

・テキストのMatrix_refからMatrixを構築するコードには、以下の問題がある
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>::Matrix(const Matrix_ref<U,N>& x)
			:desc{x.desc}, elems{x.begin(),x.end()}
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");
		}

	①x.descはMatrix_refのprivateメンバのため、Matrixからアクセスできない
	②Matrix_refは要素が連続配置されていないため、desc(Matrix_slice)を
	　単純にコピーできない（新規に作成されるMatrixは要素を連続的に配置する）
	　
	この問題を対策するため、以下のように変更した
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>::Matrix(const Matrix_ref<U,N>& x)
		// 2016.11.08, 2016.11.12 change
			//:desc{x.desc}, elems{x.begin(),x.end()}
			:desc{x.descriptor()}, elems(x.begin(),x.end())
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			// 2016.11.12 add
			desc.start = 0;
			desc.extents = x.descriptor().extents;
			Matrix_impl::compute_strides(desc);
		}

・Matrix_refをMatrixに代入する処理にも同様な問題がある
	以下のように変更
	
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>& Matrix<T,N>::operator=(const Matrix_ref<U,N>& x)
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			desc = x.desc;
			elems.assign(x.begin(),x.end());
			return *this;
		}

		↓
		
	// Matrix: assign Matrix_ref
	template<typename T, size_t N>
		template<typename U>
		Matrix<T,N>& Matrix<T,N>::operator=(const Matrix_ref<U,N>& x)
		{
			static_assert(Convertible<U,T>(), "Matrix constructor: incompatible element types");

			std::vector<T> nv{x.begin(), x.end()};	// exception safe

			desc.start = 0;
			desc.extents = x.descriptor().extents;
			Matrix_impl::compute_strides(desc);
			elems = nv;
			return *this;
		}



【29.2.1:　Matrix_refの反復子の追加】

日付：　2016.11.12
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrix_refからMatrixを構築、及び、Matrix_refをMatrixに代入する際に
	Matrix_refに反復子の処理を提供する必要がある。
	
	以下のように実現：
	
	①Matrix_refの反復子クラスを提要
		const用（Matrix_ref_const_iterator）と、非const用（Matrix_ref_iterator）の2つのクラスを定義
		
	②Matrixクラスに、反復子を返すbegin()と、end()を追加
		const用と、非const用のそれぞれ1つずつ

	①の反復子クラスは以下のように定義（const用の反復子も同様）
		
		template<typename T, size_t N>
		class Matrix_ref_iterator : public std::iterator<std::input_iterator_tag, T>
		{
		public:
			bool operator==(const Matrix_ref_iterator& other) const ;
			bool operator!=(const Matrix_ref_iterator& other) const
				{ return !(*this == other); }
			Matrix_ref_iterator& operator++();
			T& operator*();

			static Matrix_ref_iterator begin(Matrix_ref<T,N>* ref);
			static Matrix_ref_iterator end(Matrix_ref<T,N>* ref);

		private:
			Matrix_ref_iterator(Matrix_ref<T,N>* ref);

			Matrix_ref<T,N> *ref;
			std::array<size_t, N> cur;
		};

	ここで、反復子は、反復対象のMatrix_refへのポインタ(ref)と、
	今どこを反復しているかを示すarray型のインデックス（cur）を
	データメンバとして保持する。
	
	begin()に対応するインデックスは、(0,0,...0)であり、end()のインデックスは、
	(extents[0],0,...0)である。
	
	反復子の前進操作は、最下位のインデックス値から順次インクリメントする
	そして、もし終端に到達した、終端を示すインデックス値に設定する
	
		template<typename T, size_t N>
		Matrix_ref_iterator<T,N>& Matrix_ref_iterator<T,N>::operator++()
		{
			int i = N-1;
			while (i >= 0) {
				++cur[i];
				if (cur[i] < ref->extent(i)) return *this;
				cur[i] = 0;
				--i;
			}

			// reach to end
			cur[0] = ref->extent(0);
			return *this;
		}

	反復子の参照外し(*)は、インデックスから要素にアクセスするように、
	Matrix_refに依頼（Matrix_refに対応するメソッドを追加）
	
		template<typename T, size_t N>
		T& Matrix_ref_iterator<T,N>::operator*()
		{
			return ref->at(cur);
		}

	②反復子に関連するMatrix_refのメンバは以下のように定義

		template<typename T, size_t N>
		class Matrix_ref {
		public:
				・・・
			using iterator = Matrix_ref_iterator<T,N>;
			using const_iterator = Matrix_ref_const_iterator<T,N>;
				・・・
			iterator begin() { return iterator::begin(this); }
			const_iterator begin() const { return const_iterator::begin(this); }
			iterator end() { return iterator::end(this); }
			const_iterator end() const { return const_iterator::end(this); }
				・・・
			T& at(std::array<size_t,N>& i) { return *(ptr + desc.at(i)); }
			const T& at(std::array<size_t,N>& i) const 	{ return *(ptr + desc.at(i)); }

		private:
			Matrix_slice<N> desc;
			T* ptr;
		};


【29.3.2:　Matrixの混合演算の関数テンプレート宣言の誤り】

日付：　2016.11.11、2016.11.18
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrixの混合演算関数テンプレート関数の宣言に誤りがある

		typename RT = Matrix<Common_type<Value_type<T>,Value_type<T2>>,N>>
	の箇所は、
		typename RT = Common_type<T,T2>>
	でなければならない
	
		template<typename T, typename T2, size_t N,
			//typename RT = Matrix<Common_type<Value_type<T>,Value_type<T2>>,N>>
			typename RT = Common_type<T,T2>>
		Matrix<RT,N> operator+(const Matrix<T,N>& a, const Matrix<T2,N>& b)
		{
			Matrix<RT,N> res = a;
			res+=b;
			return res;
		}

【29.3.2:　Matrixの混合演算実現のため、他の型のMatrixからのコンストラクタが必要】

日付：　2016.11.11、2016.11.20
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Matrixの混合演算を実現するため、他の型を要素とするMatrixを引数とする
	Matrixのコンストラクタが必要となる。
	
	以下の混合演算において、Matrix<RT,N> res = a;　の行が該当する

	
		template<typename T, typename T2, size_t N,
			typename RT = Common_type<T,T2>>
		Matrix<RT,N> operator+(const Matrix<T,N>& a, const Matrix<T2,N>& b)
		{
			Matrix<RT,N> res = a;
			res+=b;
			return res;
		}

	Matrixクラスに以下のメンバを追加
	
		// 2016.11.11 add
		template<typename U>
			Matrix(const Matrix<U,N>&);
		template<typename U>
			Matrix& operator=(const Matrix<U,N>&);

