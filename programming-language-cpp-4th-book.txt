【履歴】

第2章　C++を探索しよう：基本

	2016.03.15、2016.03.18、2016.03.19　2.2:基本
	2016.03.20	2.3:ユーザ定義型、2.4:モジュール性

第3章　C++を探索しよう：抽象化のメカニズム

	2016.03.20、2016.03.22、2016.03.24、2016.03.26	3.2:クラス
	2016.03.27	3.3:コピーとムーブ
	2016.03.27、2016.03.28、2016.03.30、2016.04.02	3.4:テンプレート

第4章　C++を探索しよう：コンテナとアルゴリズム

	2016.04.02	4.2:文字列
	2016.04.02	4.3:ストリーム入出力
	2016.04.02	4.4:コンテナ
	2016.04.03	4.5:アルゴリズム
	
第5章　C++を探索しよう：並列処理とユーティリティ

	2016.04.03	5.2:資源管理
	2016.04.03、2016.04.04、2016.04.05	5.3:並行処理
	2016.04.05、2016.04.06、2016.04.07	5.4:小規模ユーティリティ
	2016.04.07	5.5:正規表現
	2016.04.07、2016.04.08	5.6:数学ライブラリ
	
第6章　型と宣言

	2016.04.09	6.2:型
	2016.04.09、2016.04.10、2016.04.11	6.3:宣言
	2016.04.12	6.4:オブジェクトと値、6.5:型別名

第7章　ポインタと配列と参照

	2016.04.13	7.2:ポインタ
	2016.04.13、2016.04.14	7.3:配列
	2016.04.15、2016.04.16	7.4:配列の内部を指すポインタ
	2016.04.16	7.5:ポインタとconst、7.6:ポインタと所有権
	2016.04.17	7.7:参照

第8章　構造体と共用体と列挙体

	2016.04.17、2016.04.18、2016.04.20、2016.04.21	8.2:構造体
	2016.04.21、2016.04.22	8.3:共用体
	2016.04.23	8.4:列挙体
	
第9章　文

	2016.04.23	9.3:文としての宣言
	2016.04.23、2016.04.24	9.4:選択文
	2016.04.24	9.5:繰り返し文、9.6:goto文
	
第10章　式

	2016.04.24	10.2:電卓プログラム
	
	
＠＠　セットアップ　＠＠
【Pleiadesのアップデート】
日付：　2016.03.23
コメント：

	Pleiadesを、pleiades-e4.5-cpp-jre_20160312.zip　にアップデート
	今回は、C/C++　FullEditionを導入したため、MinGWも更新
	MinGWのバージョンは、
		g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0

	バージョンをアップしても、
		「Ohter　dialect　flag」に　-std=c++11　を入力
		「プリプロセッサ」に　__cplusplus=201103L　を入力
	しないとうまく動作しない（コンパイル時のエラーが表示される）


＠＠　Usage　＠＠


＠＠　問題、コメント　＠＠

【2.4.3.2.不変条件ーlength_errorの初期化処理がコンパイルエラー】

日付：　2016.03.20
コメント：
	length_errorのデフォルトコンストラクタ呼び出しでコンパイルエラーが発生
	文字列引数をとるコンストラクタ呼び出しに変更
	
	if( s < 0 ) throw length_error{"Vector::Vector"};
	// no matching function for call to 'std::length_error::length_error(<brace-enclosed initializer list>)'
		↓
	if( s < 0 ) throw length_error{"Vector::Vector"};

【3.2.1.3.　initializer_listでコンパイルエラー】

日付：　2016.03.22
バージョン：
	eclipse：　Version:Mars.2 Release(4.5.2)
	MinGW：　gcc(GCC)4.9.3
現象：
	initializer_listでコンパイルエラーが出る
対策：
	eclipse/CDT上で以下を行う
	
	１）プロジェクトを選択し、右クリックで「プロパティー」を選択
	１．１）「C/C++ビルド」「設定」を選択
	１．１．１）「GCC　C++　Compiler」「Dialect」を選択し
		「Ohter　dialect　flag」に　-std=c++11　を入力
	１．１．２）「GCC　C++　Compiler」「プリプロセッサ」を選択し
		「__cplusplus=201103L」を入力
	２）「プロジェクト」「C/C++索引」「再ビルド」メニューを実行
	
	この後、ビルド、実行すると、うまくいった

【3.2.1.3.　コンテナの初期化】

日付：　2016.03.24
コメント：
	コンテナの初期化の例題では、コピーコンストラクタとコピー代入演算子を
	定義しないと、動作しない
	
【5.3.5.2　package_taskの例で異常終了する】

日付：　2016.04.05
現象：

以下のエラーメッセージが出力され、異常終了する。
	This application has requested the Runtime to terminate it in an unusual way.
	Please contact the application's support team for more information.

対策：
	スレッドを作成したcomp2関数から戻る前に、スレッドの終了を待つ
	処理を入れた

	// 2016.04.05 add
	t1.join(); t2.join();
	
	return f0.get() + f1.get();
	
	つまり、futureに対して、get()を呼び出すだけでは、スレッドの終了が
	保証できない模様

【5.6.2　complexの型変換のエラー】

日付：　2016.04.07
現象：
	スカラー型の異なるcomplex間の型変換と、complexとスカラー型の混合演算で
	エラーが出る
	

	complex<long double> ld {fl+sqrt(db)};
		↓
	no match for 'operator+' (operand types are 'std::complex<float>' and 'std::complex<double>')
	
	db += fl*3;
		↓
	no match for 'operator*' (operand types are 'std::complex<float>' and 'int')

	fl = pow(1/fl, 2);
		↓
	no match for 'operator/' (operand types are 'int' and 'std::complex<float>')

【6.2.2　論理型：　整数からboolへの縮小変換】

日付：　2016.04.09
コメント：
	整数からboolへの縮小変換がエラーとならない（ワーニングも出力されない）

		bool b2 {7};

【6.3.5　初期化：　初期化並びによる初期化】

日付：　2016.04.10
コメント：
	変数を使った初期化並びによる初期化において、縮小変換の場合もエラーとならず、
	ワーニングとなる
	
	int x3 {val};
	// narrowing conversion of 'val' from 'double' to 'int' inside { } [-Wnarrowing]

	char c3 {val2};
	// narrowing conversion of 'val2' from 'int' to 'char' inside { } [-Wnarrowing]

	但し、常数を使った初期化並びの初期化では、縮小変換の場合はエラーとなる
	
	//char c5 {264};
	// narrowing conversion of '264' from 'int' to 'char' inside { } [-Wnarrowing]

	//int x4 {2.0};
	// narrowing conversion of '2.0e+0' from 'double' to 'int' inside { } [-Wnarrowing]


【6.3.5　初期化：　初期化並びによる型推定】

日付：　2016.04.10
コメント：
	単一要素の初期化並びによる型推定では、initilizer_listとならずに、
	その要素の値で初期化される。
	以下の例では、z1は整数値９９に初期化される

	auto z1 {99};

【6.3.5.2　初期化子並び：　autoによる型推定】

日付：　2016.04.10
バージョン：g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの記述とは異なり、初期化子リストを伴ったautoによる型推定では、
	以下のエラーが出る

	auto x1 {1, 2, 3, 4};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	auto x2 {1.0, 2.25, 3.5};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	auto x3 {1.0, 2};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	// unable to deduce 'std::initializer_list<_Tp>' from '{1.0e+0, 2}'

【6.3.6.2　autoと｛｝並び】

日付：　2016.04.10
バージョン：
コメント：
	テキストと異なり、単一要素を持つ｛｝並びに対して、autoで型推定すると、
	並びの値の型に型推定される
	
	auto v1ai {12345};
	auto v2ai {'c'};
	auto v3ai {f()};
	
	では、それぞれ、int、char、char型となる

【7.3　配列：変数を要素数とする配列がエラーとならない】

日付：　2016.04.10
コメント：
	変数を要素数とする配列の定義がエラーとならない。
	以下の例で、v1[0]は10と表示される
	
	
	void f(int n)
	{
		int v1[n];
		vector<int> v2(n);

		cout << "v1[0] = " << v1[0] << '\n';
		cout << "v2[0] = " << v2[0] << '\n';
	}
	int main()
	{
		f(10);
	}

【7.3.2　文字列リテラル：　char*へのリテラルの代入】

日付：　2016.04.14
コメント：
	テキストの記述と異なり、char*への文字列リテラルの代入はエラーとならず、
	warningとなる。
	そのあとで、char*を通した代入により、システムがダウンする
	
	char* p = "Plato";
		// ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]
	p[4] = 'e';
	
【7.3.2.2　大規模文字セット：　unicode文字が出力されない】

日付：　2016.04.14
コメント：
	windows上で、unicode文字、utf8、utf16、utf32が正しく出力されない
	
	以下のプログラムを実行すると、

	cout << "folder\\file" << '\n';
	cout << R"(folder\file)" << '\n';
	cout << u8"folder\\file" << '\n';
	cout << u8R"(folder\file)" << '\n';
	cout << u"folder\\file" << '\n';
	cout << uR"(folder\file)" << '\n';
	cout << U"folder\\file" << '\n';
	cout << UR"(folder\file)" << '\n';
	cout << u8"The official vowels in Danish are: a, e, i, o, u, \u00E6, \u00F8, \u00E5 and y." << '\n';

	下記の出力が得られる

	folder\file
	folder\file
	folder\file
	folder\file
	0x40403e
	0x40403e
	0x404058
	0x404058
	The official vowels in Danish are: a, e, i, o, u, ﾃｦ, ﾃｸ, ﾃ･ and y.

【8.2.3　構造体とクラス：初期化リストから配列に代入できない】

日付：　2016.04.18、2016.04.20
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの例で、配列を初期化リストから代入する箇所でエラーとなる
	
	state = {st[0], st[1]};
	zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
	zip = {'0', zi[0], zi[1], zi[2], zi[3]};

【8.2.4　構造体と配列：配列を内包する構造体では、処理化リストによる初期化ができない】

日付：　2016.04.18、2016.04.20、2016.04.21
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの例では、Arrayの初期化に失敗する
	
		struct Array {
			Point elem[3];
		};

		Array points2 {{1,2},{3,4},{5,6}};
			// initializers for 'Array'
対策：
	①Arrayのインスタンスを初期化するイニシャライザリストの括弧をもう一つ付ける
	
		Array points2 {{{1,2},{3,4},{5,6}}};
		
	②Arrayにinitailizer_listを引数とするコンストラクタを追加する

		struct Array {
			Point elem[3];
			// ...
			Point3Array(const initializer_list<Point>& args)
			{ assert(args.size() == 3);
			  copy(args.begin(), args.end(), elem); }
			// ...
		};
		
		Array points2 {{1,2},{3,4},{5,6}};
			// initializers for 'Array'


【8.2.4　構造体と配列：arrayテンプレートの値引数の型が異なる】
	
日付：　2016.04.21
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキスト例では、arrayテンプレートを使用している箇所で、
		no matching function for call to 'print(PointArray&)'
	のエラーが出る

原因：
	arrayテンプレートクラスの定義では、値引数の型がsize_tで、
	printテンプレート関数の値引数が型がintであり、同一の型として認識されない
	printテンプレート関数のテンプレート引数型をsize_tに変更することで対策
	
【8.3.1　共用体とクラス：unionの初期化エラー】

日付：　2016.04.22
コメント：
	テキストの記述とは異なり、クラス内初期化子が指定されていないメンバ
	に対して、unionオブジェクトの初期化子を指定しようとすると、エラーとなる
	
	union U2 {
		int a;
		const char* p {""};
	};

	U2 x1;
	U2 x2 {7};
		// no matching function for call to 'U2::U2(<brace-enclosed initializer list>)'


【8.3.2　無名共用体】

日付：　2016.04.22
コメント：

	テキストの例に以下の問題がある
	
	①文法エラー
	
	Entry2& Entry2::operator=(const Entry2& e)　関数内で、以下の行でエラー
	
		new(&s)(e.s);

	正しくは、

		new(&s) string{e.s};

	としなければならない
	
	②typeメンバへの設定ミス
	
		switch (e.type) {
		case Tag::number:
			i = e.i;
			break;
		case Tag::text:
			// new(&s)(e.s);
			new(&s) string{e.s};
			type = e.type;
			break;
		}

		return *this;
		
	において、this->typeがTag::textで、e.typeがTag::numberの時、
	this->typeが、Tag::textのままとなる


【8.4.1　enum class: 根底型に収まらない値の初期化】

日付：　2016.04.23
コメント：
	根底型に収まらない enum class 変数の初期化時に、エラーやワーニング
	が出力されない

	enum class Flag : char { x=1, y=2, z=4, e=8 };
	Flag f4 = static_cast<Flag>(999);


【9.4.1　if文：　if文の分岐が宣言だけからる場合にエラーとならない】

日付：　2016.04.23
コメント：
	テキストの記述と異なり、if文の分岐が宣言のみからなる場合、エラーとならない

		if (i)
			int x = i+2;
				// unused variable 'x' [-Wunused-variable]
