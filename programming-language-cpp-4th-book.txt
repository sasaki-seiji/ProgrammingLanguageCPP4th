【履歴】

第2章　C++を探索しよう：基本

	2016.03.15、2016.03.18、2016.03.19　2.2:基本
	2016.03.20	2.3:ユーザ定義型、2.4:モジュール性

第3章　C++を探索しよう：抽象化のメカニズム

	2016.03.20、2016.03.22、2016.03.24、2016.03.26	3.2:クラス
	2016.03.27	3.3:コピーとムーブ
	2016.03.27、2016.03.28、2016.03.30、2016.04.02	3.4:テンプレート

第4章　C++を探索しよう：コンテナとアルゴリズム

	2016.04.02	4.2:文字列
	2016.04.02	4.3:ストリーム入出力
	2016.04.02	4.4:コンテナ
	2016.04.03	4.5:アルゴリズム
	
第5章　C++を探索しよう：並列処理とユーティリティ

	2016.04.03	5.2:資源管理
	2016.04.03、2016.04.04、2016.04.05	5.3:並行処理
	2016.04.05、2016.04.06、2016.04.07	5.4:小規模ユーティリティ
	2016.04.07	5.5:正規表現
	2016.04.07、2016.04.08	5.6:数学ライブラリ
	
第6章　型と宣言

	2016.04.09	6.2:型
	2016.04.09、2016.04.10、2016.04.11	6.3:宣言
	2016.04.12	6.4:オブジェクトと値、6.5:型別名

第7章　ポインタと配列と参照

	2016.04.13	7.2:ポインタ
	2016.04.13、2016.04.14	7.3:配列
	2016.04.15、2016.04.16	7.4:配列の内部を指すポインタ
	2016.04.16	7.5:ポインタとconst、7.6:ポインタと所有権
	2016.04.17	7.7:参照

第8章　構造体と共用体と列挙体

	2016.04.17、2016.04.18、2016.04.20、2016.04.21	8.2:構造体
	2016.04.21、2016.04.22	8.3:共用体
	2016.04.23	8.4:列挙体
	
第9章　文

	2016.04.23	9.3:文としての宣言
	2016.04.23、2016.04.24	9.4:選択文
	2016.04.24	9.5:繰り返し文、9.6:goto文
	
第10章　式

	2016.04.24、2016.04.25	10.2:電卓プログラム
	2016.04.25、2016.04.26	10.3:演算子の概要
	2016.04.26、2016.04.27、2016.04.28、2016.04.29	10.4:定数式
	2016.04.29	10.5:暗黙の型変換
	
第11章　主要な演算子

	2016.04.29	11.1:いろいろな演算子
	2016.04.29、2016.04.30	11.2:空き領域
	2016.05.01、2016.05.02	11.3:並び
	2016.05.02、2016.05.03	11.4:ラムダ式
	2016.05.03、2016.05.04	11.5:明示的型変換
	
第12章　関数

	2016.05.05	12.1:関数宣言
	2016.05.05、2016.05.06、2016.05.07	12.2:引数の受け渡し
	2016.05.08	12.3:関数多重定義
	2016.05.08、2016.05.11	12.5:関数へのポインタ
	2016.05.12	12.6:マクロ
	
第13章　例外処理

	2016.05.13、2016.05.14	13.1:エラー処理
	2016.05.14、2016.05.15	13.3:資源管理
	2016.05.16、2016.05.17	13.4:不変条件の強制
	2016.05.17、2016.05.18、2016.05.19、2016.05.20	13.5:例外の送出と捕捉
	2016.05.21、2016.05.22	13.6:vectorの実装
	
第14章　名前空間

	2016.05.23	14.2:名前空間
	2016.05.24	14.3:モジュール化とインタフェース
	2016.05.26、2016.05.27、2016.05.28	14.4:名前空間を用いた構成
	
第15章　ソースファイルとプログラム

	2016.07.09、2016.07.10	15.2:結合
	2016.07.11、2016.07.13	15.3:ヘッダの利用
	2016.07.13、2016.07.15	15.4:プログラム
	

第III部　抽象化のメカニズム

第16章　クラス

	2016.07.15、2016.07.16、2016.07.18、2016.07.19	16.2:クラスの基礎
	2016.07.20、2016.07.21、2016.07.22	16.3:具象クラス
	
第17章　構築と後始末とコピーとムーブ

	2016.07.22	17.1:はじめに
	2016.07.22、2016.07.24	17.2:コンストラクタとデストラクタ
	2016.07.24、2016.07.25、2016.07.26、2016.07.27、2016.07.28
				17.3:クラスオブジェクトの初期化
	2016.07.28、2016.07.29、2016.07.30	17.4:メンバと基底の初期化
	2016.07.30、2016.07.31	17.5:コピーとムーブ
	2016.08.01、2016.08.05	17.6:デフォルト演算の生成
	

第18章　演算子の多重定義

	2016.08.06	18.1:はじめに、18.2:演算子関数
	2016.08.06、2016.08.07、2016.08.08、2016.08.09	18.3:複素数型
	2016.08.10	18.4:型変換
	

第19章　特殊な演算子

	2016.08.11、2016.08.15、2016.08.16	19.2:特殊な演算子
	2016.08.17、2016.08.18	19.3:文字列クラスString
	2016.08.18、2016.08.19	19.4:フレンド
	
第20章　派生クラス

	2016.08.21	20.2:派生クラス
	2016.08.21、2016.08.22、2016.08.23、2016.08.24	20.3:クラス階層
	2016.08.24	20.4:抽象クラス
	2016.08.26、2016.08.27	20.5:アクセス制御
	2016.08.27	20.6:メンバへのポインタ
	
第21章　クラス階層

	2016.08.27、2016.08.28	21.2:クラス階層の設計
	2016.08.29、2016.08.30、2016.09.01、2016.09.02	21.3:多重継承
	
第22章　実行時型情報

	2016.09.03、2016.09.04	22.2:クラス階層の移動
	2016.09.04	22.3:ダブルディスパッチとVisitorパターン
	2016.09.04、2016.09.05	22.5:型の識別
	2016.09.05	22.6:RTTIの利用と悪用
	
第23章　テンプレート

	2016.09.08、2016.09.09、2016.09.10	23.2:単純な文字列テンプレート
	2016.09.10	23.3:型チェック
	2016.09.11、2016.09.12、2016.09.13	13.4:クラステンプレートのメンバ
	2016.09.13、2016.09.14、2016.09.15、2016.09.16、2016.09.17	23.5:関数テンプレート
	2016.09.17	23.6:テンプレート別名
	2016.09.17	23.7:ソースコードの構成

第25章　特殊化

	2016.09.17、2016.09.18、2016.09.19	25.2:テンプレートの仮引数と実引数	
	2016.09.19、2016.09.20、2016.09.22	25.3:特殊化
	
第26章　具現化

	2016.09.23、2016.09.24	26.2:テンプレート具現化
	2016.09.24、2016.09.25	26.3:名前バインド
	
第27章　テンプレートと階層

	2016.09.27、2016.09.28	27.2:パラメータ化と階層
	2016.09.30	27.3:クラステンプレートの階層
	2016.10.01	27.4:基底クラスとしてのテンプレート
		（27.4.2:「クラス階層の線形化」はスキップ）

第28章　メタプログラミング

	2016.10.03、2016.10.05	28.2:型関数
	
	
＠＠　セットアップ　＠＠
【Pleiadesのアップデート】
日付：　2016.03.23
コメント：

	Pleiadesを、pleiades-e4.5-cpp-jre_20160312.zip　にアップデート
	今回は、C/C++　FullEditionを導入したため、MinGWも更新
	MinGWのバージョンは、
		g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0

	バージョンをアップしても、
		「Ohter　dialect　flag」に　-std=c++11　を入力
		「プリプロセッサ」に　__cplusplus=201103L　を入力
	しないとうまく動作しない（コンパイル時のエラーが表示される）


＠＠　Usage　＠＠


＠＠　問題、コメント　＠＠

【2.4.3.2.不変条件ーlength_errorの初期化処理がコンパイルエラー】

日付：　2016.03.20
コメント：
	length_errorのデフォルトコンストラクタ呼び出しでコンパイルエラーが発生
	文字列引数をとるコンストラクタ呼び出しに変更
	
	if( s < 0 ) throw length_error{"Vector::Vector"};
	// no matching function for call to 'std::length_error::length_error(<brace-enclosed initializer list>)'
		↓
	if( s < 0 ) throw length_error{"Vector::Vector"};

【3.2.1.3.　initializer_listでコンパイルエラー】

日付：　2016.03.22
バージョン：
	eclipse：　Version:Mars.2 Release(4.5.2)
	MinGW：　gcc(GCC)4.9.3
現象：
	initializer_listでコンパイルエラーが出る
対策：
	eclipse/CDT上で以下を行う
	
	１）プロジェクトを選択し、右クリックで「プロパティー」を選択
	１．１）「C/C++ビルド」「設定」を選択
	１．１．１）「GCC　C++　Compiler」「Dialect」を選択し
		「Ohter　dialect　flag」に　-std=c++11　を入力
	１．１．２）「GCC　C++　Compiler」「プリプロセッサ」を選択し
		「__cplusplus=201103L」を入力
	２）「プロジェクト」「C/C++索引」「再ビルド」メニューを実行
	
	この後、ビルド、実行すると、うまくいった

【3.2.1.3.　コンテナの初期化】

日付：　2016.03.24
コメント：
	コンテナの初期化の例題では、コピーコンストラクタとコピー代入演算子を
	定義しないと、動作しない
	
【5.3.5.2　package_taskの例で異常終了する】

日付：　2016.04.05
現象：

以下のエラーメッセージが出力され、異常終了する。
	This application has requested the Runtime to terminate it in an unusual way.
	Please contact the application's support team for more information.

対策：
	スレッドを作成したcomp2関数から戻る前に、スレッドの終了を待つ
	処理を入れた

	// 2016.04.05 add
	t1.join(); t2.join();
	
	return f0.get() + f1.get();
	
	つまり、futureに対して、get()を呼び出すだけでは、スレッドの終了が
	保証できない模様

【5.6.2　complexの型変換のエラー】

日付：　2016.04.07
現象：
	スカラー型の異なるcomplex間の型変換と、complexとスカラー型の混合演算で
	エラーが出る
	

	complex<long double> ld {fl+sqrt(db)};
		↓
	no match for 'operator+' (operand types are 'std::complex<float>' and 'std::complex<double>')
	
	db += fl*3;
		↓
	no match for 'operator*' (operand types are 'std::complex<float>' and 'int')

	fl = pow(1/fl, 2);
		↓
	no match for 'operator/' (operand types are 'int' and 'std::complex<float>')

【6.2.2　論理型：　整数からboolへの縮小変換】

日付：　2016.04.09
コメント：
	整数からboolへの縮小変換がエラーとならない（ワーニングも出力されない）

		bool b2 {7};

【6.3.5　初期化：　初期化並びによる初期化】

日付：　2016.04.10
コメント：
	変数を使った初期化並びによる初期化において、縮小変換の場合もエラーとならず、
	ワーニングとなる
	
	int x3 {val};
	// narrowing conversion of 'val' from 'double' to 'int' inside { } [-Wnarrowing]

	char c3 {val2};
	// narrowing conversion of 'val2' from 'int' to 'char' inside { } [-Wnarrowing]

	但し、常数を使った初期化並びの初期化では、縮小変換の場合はエラーとなる
	
	//char c5 {264};
	// narrowing conversion of '264' from 'int' to 'char' inside { } [-Wnarrowing]

	//int x4 {2.0};
	// narrowing conversion of '2.0e+0' from 'double' to 'int' inside { } [-Wnarrowing]


【6.3.5　初期化：　初期化並びによる型推定】

日付：　2016.04.10
コメント：
	単一要素の初期化並びによる型推定では、initilizer_listとならずに、
	その要素の値で初期化される。
	以下の例では、z1は整数値９９に初期化される

	auto z1 {99};

【6.3.5.2　初期化子並び：　autoによる型推定】

日付：　2016.04.10
バージョン：g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの記述とは異なり、初期化子リストを伴ったautoによる型推定では、
	以下のエラーが出る

	auto x1 {1, 2, 3, 4};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	auto x2 {1.0, 2.25, 3.5};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	auto x3 {1.0, 2};
	// direct-list-initialization of 'auto' requires exactly one element [-fpermissive]
	// unable to deduce 'std::initializer_list<_Tp>' from '{1.0e+0, 2}'

【6.3.6.2　autoと｛｝並び】

日付：　2016.04.10
バージョン：
コメント：
	テキストと異なり、単一要素を持つ｛｝並びに対して、autoで型推定すると、
	並びの値の型に型推定される
	
	auto v1ai {12345};
	auto v2ai {'c'};
	auto v3ai {f()};
	
	では、それぞれ、int、char、char型となる

【7.3　配列：変数を要素数とする配列がエラーとならない】

日付：　2016.04.10
コメント：
	変数を要素数とする配列の定義がエラーとならない。
	以下の例で、v1[0]は10と表示される
	
	
	void f(int n)
	{
		int v1[n];
		vector<int> v2(n);

		cout << "v1[0] = " << v1[0] << '\n';
		cout << "v2[0] = " << v2[0] << '\n';
	}
	int main()
	{
		f(10);
	}

【7.3.2　文字列リテラル：　char*へのリテラルの代入】

日付：　2016.04.14
コメント：
	テキストの記述と異なり、char*への文字列リテラルの代入はエラーとならず、
	warningとなる。
	そのあとで、char*を通した代入により、システムがダウンする
	
	char* p = "Plato";
		// ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]
	p[4] = 'e';
	
【7.3.2.2　大規模文字セット：　unicode文字が出力されない】

日付：　2016.04.14
コメント：
	windows上で、unicode文字、utf8、utf16、utf32が正しく出力されない
	
	以下のプログラムを実行すると、

	cout << "folder\\file" << '\n';
	cout << R"(folder\file)" << '\n';
	cout << u8"folder\\file" << '\n';
	cout << u8R"(folder\file)" << '\n';
	cout << u"folder\\file" << '\n';
	cout << uR"(folder\file)" << '\n';
	cout << U"folder\\file" << '\n';
	cout << UR"(folder\file)" << '\n';
	cout << u8"The official vowels in Danish are: a, e, i, o, u, \u00E6, \u00F8, \u00E5 and y." << '\n';

	下記の出力が得られる

	folder\file
	folder\file
	folder\file
	folder\file
	0x40403e
	0x40403e
	0x404058
	0x404058
	The official vowels in Danish are: a, e, i, o, u, ﾃｦ, ﾃｸ, ﾃ･ and y.

【8.2.3　構造体とクラス：初期化リストから配列に代入できない】

日付：　2016.04.18、2016.04.20
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの例で、配列を初期化リストから代入する箇所でエラーとなる
	
	state = {st[0], st[1]};
	zip = {zi[0], zi[1], zi[2], zi[3], zi[4]};
	zip = {'0', zi[0], zi[1], zi[2], zi[3]};

【8.2.4　構造体と配列：配列を内包する構造体では、処理化リストによる初期化ができない】

日付：　2016.04.18、2016.04.20、2016.04.21
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの例では、Arrayの初期化に失敗する
	
		struct Array {
			Point elem[3];
		};

		Array points2 {{1,2},{3,4},{5,6}};
			// initializers for 'Array'
対策：
	①Arrayのインスタンスを初期化するイニシャライザリストの括弧をもう一つ付ける
	
		Array points2 {{{1,2},{3,4},{5,6}}};
		
	②Arrayにinitailizer_listを引数とするコンストラクタを追加する

		struct Array {
			Point elem[3];
			// ...
			Point3Array(const initializer_list<Point>& args)
			{ assert(args.size() == 3);
			  copy(args.begin(), args.end(), elem); }
			// ...
		};
		
		Array points2 {{1,2},{3,4},{5,6}};
			// initializers for 'Array'


【8.2.4　構造体と配列：arrayテンプレートの値引数の型が異なる】
	
日付：　2016.04.21
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキスト例では、arrayテンプレートを使用している箇所で、
		no matching function for call to 'print(PointArray&)'
	のエラーが出る

原因：
	arrayテンプレートクラスの定義では、値引数の型がsize_tで、
	printテンプレート関数の値引数が型がintであり、同一の型として認識されない
	printテンプレート関数のテンプレート引数型をsize_tに変更することで対策
	
【8.3.1　共用体とクラス：unionの初期化エラー】

日付：　2016.04.22
コメント：
	テキストの記述とは異なり、クラス内初期化子が指定されていないメンバ
	に対して、unionオブジェクトの初期化子を指定しようとすると、エラーとなる
	
	union U2 {
		int a;
		const char* p {""};
	};

	U2 x1;
	U2 x2 {7};
		// no matching function for call to 'U2::U2(<brace-enclosed initializer list>)'


【8.3.2　無名共用体】

日付：　2016.04.22
コメント：

	テキストの例に以下の問題がある
	
	①文法エラー
	
	Entry2& Entry2::operator=(const Entry2& e)　関数内で、以下の行でエラー
	
		new(&s)(e.s);

	正しくは、

		new(&s) string{e.s};

	としなければならない
	
	②typeメンバへの設定ミス
	
		switch (e.type) {
		case Tag::number:
			i = e.i;
			break;
		case Tag::text:
			// new(&s)(e.s);
			new(&s) string{e.s};
			type = e.type;
			break;
		}

		return *this;
		
	において、this->typeがTag::textで、e.typeがTag::numberの時、
	this->typeが、Tag::textのままとなる


【8.4.1　enum class: 根底型に収まらない値の初期化】

日付：　2016.04.23
コメント：
	根底型に収まらない enum class 変数の初期化時に、エラーやワーニング
	が出力されない

	enum class Flag : char { x=1, y=2, z=4, e=8 };
	Flag f4 = static_cast<Flag>(999);


【9.4.1　if文：　if文の分岐が宣言だけからる場合にエラーとならない】

日付：　2016.04.23
コメント：
	テキストの記述と異なり、if文の分岐が宣言のみからなる場合、エラーとならない

		if (i)
			int x = i+2;
				// unused variable 'x' [-Wunused-variable]

【10.3.4　一時オブジェクト】

日付:　2016.04.26
コメント：
	テキストの例に以下の間違いがある
	①stringはmoveメンバ関数を持たない
	②stringコンストラクタを{n,ch}で呼び出すと、initializer_list引数として
	処理される
	
	s.move(string{n,ch});
		↓
	s = move(string{n,ch});
		// narrowing conversion of 'n' from 'int' to 'char' inside { } [-Wnarrowing]
		↓
	s = move(string(n,ch));

【10.4.2　定数式中のconst：sqrtを用いたconstexprがエラーとならない】

日付：　2016.04.26
コメント：
	テキストの記述と異なり、sqrtを用いたconstexprがエラーとならない

	const int y = sqrt(x);
	constexpr int yy = y;
	
	ここで、ｙとｙｙは、値2を持つ


【5.4.3　リテラル型：constexprメンバ関数にconst関数指定が必要】

日付：　2016.04.27
コメント：
	テキストの記述と異なり、constexprメンバ関数にもconst関数指定がが必要である
	
	struct Point {
		...
		//constexpr Point up(int d) { return {x, y, z+d}; }
		constexpr Point up(int d) const { return {x, y, z+d}; }
			// Invalid arguments 'Candidates are: Point up(int)	'
		...
	};
	
	constexpr Point p2 {p1.up(20)};

【10.4.5　アドレス定数式：p1+2がコンパイルエラーとならない】

日付：　2016.04.29
コメント：
	テキストの記述と異なり、定数式　p1+2がコンパイルエラーとならない
	
	constexpr const char* p1 = "asdf";
	constexpr const char* p2 = p1;
	constexpr const char* p3 = p1+2;	// OK
	constexpr char c = p1[2];

【10.5.2　変換】

日付：　2016.04.29
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	・テキストの記述と異なり、｛｝形式の初期化はエラーでなく、ワーニングとなる
		char c {d};
			// narrowing conversion of 'd' from 'double' to 'char' inside { } [-Wnarrowing]
	・縮小変換のワーニングは、-Wconversionオプションを付けた場合のみ出力される

【11.3.3　非修飾並び】

日付：　2016.05.01
コメント：
	テキストの記述と異なり、+=　の右辺に非修飾｛｝並びを指定するとエラーとなる
	v = v + {88} の意味に解釈され、+演算でエラーとなる模様
	
	int v {7};
	v += {88};
		// invalid operands of types 'int' and '<brace-enclosed initializer list>' to binary 'operator+'


【11.4.3.1　ラムダ式と生存期間】

日付：　2016.05.02
コメント：
	クラスオブジェクトへの非constな参照を値でキャプチャするとエラーが出る
	
		void setup2(Menu& m)
		{
			Point p1{1,2}, p2{3,4}, p3{5,6};

			m.add("draw triagle", [=]{ m.draw(p1, p2, p3); });
				// passing 'const Menu' as 'this' argument discards qualifiers [-fpermissive]
		}

	以下のように、参照としてキャプチャする必要がある
	
		m.add("draw triagle", [=, &m]{ m.draw(p1, p2, p3); });

【11.4.4　呼び出しとリターン】

日付：　2016.05.03
バージョン：　g++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの記述と異なり、複数のreturn文を持つラムダ式のリターン型が推定されている
	
	auto z2 = [y]{ if (y) return 1; else return 2; };
	z2();

【11.4.5　ラムダ式の型】

日付：　2016.05.03
コメント：
	テキストの記述と異なり、キャプチャを含むラムダ式から
	関数ポインタ変数を初期化することができる
	
		double (*p2)(double) = [&](double a) { return sqrt(a); };
		
	この場合、実際には何もキャプチャしていないのでコンパイルできるものと思われる
	
【11.5.4　関数形式キャスト】

日付：　2016.05.04
コメント：
	テキストの記述と異なり、関数形式(および、C言語形式も）でのchar*から
	intへのキャストがエラーとなる
	
		int b = int(p);
			// cast from 'char*' to 'int' loses precision [-fpermissive]
		int c = (int)p;
			// cast from 'char*' to 'int' loses precision [-fpermissive]

【12.1.6　constexpr関数】

日付：　2016.05.05
コメント：
	テキストの記述と異なり、定数でない配列サイズがエラーとならない
	
	void f(int n)
	{
		・・・
		char a[fac(4)];
		char a2[fac(n)];
		・・・
	}
	

【12.2.3　並び引数】

日付：　2016.05.06
コメント：
	配列への参照引数の初期化でエラーが出る

	・テキストの記載に従うと、int[4]の右辺値から、非定数のint(&)[4]を
	初期化できないとのメッセージ

	f3({1,2,3,4});
		// invalid initialization of non-const reference of type 'int (&)[4]' from an rvalue of type 'int [4]'

	・関数宣言をconst参照に変更しても、以下のエラーが出る

	template<typename T, int N>
	void f3(const T (&r)[N]) { cout << "f3()\n"; }

	void g()
	{
		・・・
		f3({1,2,3,4});
			// Invalid arguments 'Candidates are: void f3(const #0 (&)[3 #1 0])	'
		・・・
	}

【13.3.1:finally　Final_actionクラスのコピーコンストラクタの削除に関するエラー】

日付：　2016.05.15
コメント：
	テキストの例では、Final_actionクラスのコピーコンストラクタを削除しているが、
	これを使っている箇所があり、エラーとなる

①finallyテンプレート関数

	template<typename F>
	Final_action<F> finally(F f)
	{
		return Final_action<F>(f);
			// use of deleted function 'Final_action<F>::Final_action(const Final_action<F>&) [with F = test()::<lambda()>]'
	}
	
		// use of deleted function 'Final_action<F>::Final_action(const Final_action<F>&) [with F = test()::<lambda()>]'

②test関数内のブロックの中
		
	{
		var = 1;
		auto act2 = finally([&]{ cout << "finally!\n"; var = 7; });
			// use of deleted function 'Final_action<F>::Final_action(const Final_action<F>&) [with F = test()::<lambda()>]'
		cout << "var = " << var << '\n';
	}

【13.6.3　vector_baseのムーブ代入が無限再帰】

日付：　2016.05.22
コメント：
	テキストの例題を実行すると、vector_baseのムーブ代入とswapが無限再帰となる
	
①vectorの代入演算子を以下のように定義

	template<typename T, typename A>
	vector<T,A>& vector<T,A>::operator=(const vector& a)
	{
		vector_base<T,A> b {a.vb.alloc, a.size()};
		uninitialized_copy(a.vb.elem, a.vb.space, b.elem);
		destroy_elements();
		swap(vb, b);
		return *this;
	}

	ここで、std::swapは、内部的に、vector_baseのムーブコンストラクタと、
	ムーブ代入を呼び出す

②vector_baseのムーブ代入は以下のように定義されている

	template<typename T, typename A>
	vector_base<T,A>& vector_base<T,A>::operator=(vector_base&& a)
	{
		swap(*this, a);
		return *this;
	}

	ここで、vector_baseに対するswapが呼ばれているため、無限再帰となる
	
③vector_baseのムーブ代入を以下のように修正

	template<typename T, typename A>
	vector_base<T,A>& vector_base<T,A>::operator=(vector_base&& a)
	{
		// 2016.05.22 stack overflow
		//swap(*this, a);
		this->alloc = a.alloc;
		this->elem = a.elem;
		this->space = a.space;
		this->last = a.last;
		a.elem = a.space = a.last = nullptr;

		return *this;
	}


【14.4.6　namespace内のテンプレートクラスの特殊化】

日付：　2016.05.28
コメント：

	テキストの例題で、Popularネームスペースのテンプレートクラスclass　Cの
	特殊化でコンパイルエラーが出る
	
	template<typename T>
	class Popular::C<T*> { };
		// specialization of 'template<class T> class Popular::V3_2::C' in different namespace [-fpermissive]

	ネームスペースに入って、特殊化を行うとコンパイルできる
	
	namespace Popular {
		template<typename T>
		class C<T*> { };
	}

【14.4.6　#include の繰り返し】

日付：2016.05.28
コメント：

	double Popular::V3_0::f(double d) がコンパイルエラー
	
	V3_0.hのインクルード中で再度V3_common.hをインクルードするところが
	うまくいっていない模様
	
	// Popular.h
	namespace Popular {
		inline
		#include "V3_2.h"
		#include "V3_0.h"
		#include "V2_4_2.h"
	}
	
	// V3_2.h
	namespace V3_2 {
		int f(int);
		#include "V3_common.h"
	}

	// V3_common.h
	double f(double);
	template<typename T>
		class C { };

	// V3_0.h
	namespace V3_0 {
		#include "V3_common.h"
	}

	// Popular_V3_0.cpp
	double Popular::V3_0::f(double d)
	{
		cout << "Popular::V3_0::f(double: " << d << ")\n";
	}
		// Member declaration not found


【15.4.3　at_quick_exit, quick_exit】

日付：2016.07.15
コメント：

	at_quick_exit, quick_exit が以下のメッセージでコンパイルエラーとなる
	
	'at_quick_exit' was not declared in this scope
	'quick_exit' was not declared in this scope


【16.2.6　静的クラス変数の初期化】

日付：2016.07.16
コメント：
	大域のDateインスタンスを初期化するとき、Dateのコンストラクタが参照する
	static変数との初期化順により、正しく初期化されない
	
	//　利用者のcppファイル
	Date2 d1 {15};
	Date2 d2 = Date2{15};
	
	//　Dateの実装
	static Date2 today {16, 7, 2016};

	Date2::Date2(int dd, int mm, int yy)
	{
		d = dd ? dd : today.d;
		m = mm ? mm : today.m;
		y = yy ? yy : today.y;
	}

【16.2.7　静的データの複製】

日付：2016.07.16
コメント：
	初期値を持つ変数date_initializerをヘッダに記載すると、
	それをインクルードする全てのcppファイルに変数が複製されてしまう

【16.2.12　多重定義解決】

日付：　2016.07.18
コメント：
	テキストの記述とは異なり、Dateとintの多重定義解決では
	エラーとならず、int引数バージョンがコールされる
	
	void f1(Date);
	void f2(Date);
	void f2(int);

	void h()
	{
		f1({});
		f2({});		// f2(int)に解決
		f2(Date{});
	}

【16.2.13　privateのメンバクラス】

日付：2016.07.18
コメント：
	TreeクラスのNodeクラスメンバがprivateなので、Node*を引数とする、
	Treeクラスの公開関数gを呼び出す手段がない
	
	template<typename T>
	void Tree<T>::g(Node* p)
	{
		//value_type val = right->value;
			//  'right' was not declared in this scope
		value_type v = p->right->value;
		p->f(this);
	}


【17.3.3　定数参照のクラス内初期化ができていない】

日付：　2016.07.26
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	定数参照のクラス内初期化で、9に初期化したメンバが0となっている
	
	int glob {9};

	struct X {
		const int a1 {7};
		const int& r {9};
		int& r1 {glob};
	};

	X x;
	
	ここで、x.rが0となる


【17.3.3　並び初期化子による初期化が動作しない】

日付：　2016.07.26
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの記述と異なり、S2クラス（string引数のコンストラクタを持つ）の
	配列とvectorを、文字列定数の並び初期化子で初期化することができない
	
	S2 a3[] { "alpha", "beta" };
		→ error: conversion from 'const char [6]' to non-scalar type 'S2' requested

	vector<S2> v3 { "alpha", "beta" };
		→ no matching function for call to 'S2::S2(const char&)'

	vector<S2> v22(10, "");
		→ error: no matching function for call to 'std::vector<S2>::vector(int, const char [1])'

【17.3.4　mapp::insertがコンパイルエラー】

日付：　2016.07.26
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの例の以下の記述がコンパイルエラーとなる

	years.insert({{"Bjane", "Stroustrup"}, {1950, 1975, 1985}});
		// Invalid arguments '


【17.6,3,3　デフォルトコピーコンストラクタ生成がワーニングとならない】

日付：　2016.08.01
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストの記述と異なり、デストラクタを明示的に定義した際の、
	デフォルトコピーコンストラクタ生成がワーニングとならない

【19.2.1　添え字演算子：ローカルコピーの参照を返している】

日付：　2016.08.11
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	テキストのAssoc::operator[]のコードは、vectorの要素のローカルコピーを
	返しているため、実行時、システムエラーとなる

	//for (auto x : vec)
	for (auto& x : vec)
		// warning: reference to local variable 'x' returned [-Wreturn-local-addr]
		if (s == x.first) return x.second;


【19.2.2　関数呼び出し演算子：｛｝並びを右辺に持つ+=演算子】

日付：　2016.08.11
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	
	テキストのラムダ関数の例で、｛｝並びを右辺に持つ、complexの+=演算子が
	コンパイルエラーとなる
	
	//for_each(vec.begin(), vec.end(),[](complex<double>& a){ a+={2,3}; });
	for_each(vec.begin(), vec.end(),[](complex<double>& a){ a+=complex<double>{2,3}; });
		// error: no match for 'operator+=' (operand types are 'std::complex<double>' and '<brace-enclosed initializer list>')

【19.2.2　関数呼び出し演算子：ラムダ式のキャプチャリスト】

日付：　2016.08.11
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	
	テキストのラムダ関数の例で、キャプチャリストの指定抜け
	
	//for_each(lst.begin(), lst.end(),[](complex<double>& a){ a+=z; });
	for_each(lst.begin(), lst.end(),[z](complex<double>& a){ a+=z; });
		// error: 'z' is not captured

【19.2.5 大域のdelete演算子の引数】

日付：　2016.08.15
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキストの記述と異なり、大域のdelete演算子には、size_t引数を指定しない

	::operator delete(p, s);
		↓
　　error: invalid conversion from 'std::size_t {aka long long unsigned int}' to 'void*' [-fpermissive]

【19.2.6 complexのリテラル】

日付：　2016.08.16
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキストの記述と異なり、2+1iでは、ユーザ定義リテラルiを認識しない

		error: unable to find numeric literal operator 'operator""i'
	
	さらに、2+1.0iとすると、整数とcomplexの混合演算が解決できない
	
		no match for 'operator+' (operand types are 'int' and 'std::complex<double>')


【19.3.4:　ムーブコンストラクタ、ムーブ代入のコンパイルエラー】

日付：　2016.08.18
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキストのムーブコンストラクタとムーブ代入では、引数で渡された
	右辺値参照参照引数をmove_fromにそのまま渡すとコンパイルエラーとなる
	（再度、move()関数を適用する必要がある）
	
	String::String(String&& x)
	{
		//move_from(x);
		move_from(move(x));
			// error: cannot bind 'String' lvalue to 'String&&'
	}

【22.2.4:　関数ポインタの型別名のコンパイルエラー】

日付：　2016.09.04
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキストの記載の、Io_objを返す関数ポインタ別名の定義が意図通り認識されない

	ヘッダー
	using Pf = Io_obj*(istream&);
	extern map<string, Pf> io_map;

	利用箇所
	io_map[string("Io_circle")] = &Io_circle::new_circle;
		↓
cannot convert 'Io_obj* (*)(std::istream&) {aka Io_obj* (*)(std::basic_istream<char>&)}' to 'std::map<std::__cxx11::basic_string<char>, Io_obj*(std::basic_istream<char>&)>::mapped_type {aka Io_obj*(std::basic_istream<char>&)}' in assignment
	関数ポインタ別名定義を以下のように変更：
	using Pf = Io_obj*(*)(istream&);


【22.2.4:　Ioテンプレートクラスの静的関数の戻り値】

日付：　2016.09.04
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	Ioテンプレートクラスのnew_io関数の戻り値を、Io_obj*としないと、
	関数ポインタマップio_mapと型が合わなくなる
	

	// 2016.09.04 bug-fix
	//static Io* new_io(istream& is) { return new Io{is}; }
	static Io_obj* new_io(istream& is) { return new Io{is}; }


【22.2.4:　テンプレート関数の宣言】

日付：　2016.09.04
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	get_va<T>テンプレート関数定義時に関数名にテンプレート修飾子をつけている
	部分がコンパイルエラーとなる
	
	// 2016.09.04 bug-fix
	template<typename T>
	//T* get_val<T>(Io_obj* p)
		// expected initializer before '<' token
	T* get_val(Io_obj* p)
	{
		・・・

【22.2.4:　テンプレート型引数をデータメンバとしたバージョン】

日付：　2016.09.04
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テンプレート仮引数TをデータメンバとしたIoクラスでは、
	データメンバに対してポリモーフィックなふるまいはしない。
	たとえば、Io<Circle>とIo<Triangle>は無関係なクラスとなり、
	Io<Shape>は、Shapeが抽象クラスのため導出することができない
	特に、get_val<Shape>はコンパイルエラーとなる
	
	この例では、Io<Circle>、Io<Triangle>、Io<int>に個別に動的キャスト
	できるかを確認する、非ポリモーフィックなコードとした


【23.2:　テンプレート関数のユーザ定義変換】

日付：　2016.09.09
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テンプレート関数は、引数マッチのためにユーザ定義変換を適用しないので、
	Stringテンプレートを引数とするテンプレート関数を追加する必要がある

	// 2016.09.09 add
	template<typename C>
	bool operator==(const String<C>& a, const C* b)
	{
		return a == String<C>(b);
	}

	// 2016.09.09 add
	template<typename C>
	bool operator==(const C* a, const String<C>& b)
	{
		return String<C>(a) == b;
	}

	// 2016.09.09 add
	template<typename C>
	bool operator!=(const String<C>& a, const C* b)
	{
		return !(a==b);
	}

	//2016.09.09 add
	template<typename C>
	bool operator!=(const C* a, const String<C>& b)
	{
		return !(a==b);
	}

	// 2016.09.09 add
	template<typename C>
	String<C>& operator+=(String<C>& s, const C* p)
	{
		return s += String<C>(p);
	}

	// 2016.09.09 add
	template<typename C>
	String<C> operator+(const String<C>& a, const C* b)
	{
		return a + String<C>(b);
	}

	// 2016.09.09 add
	template<typename C>
	String<C> operator+(const C* a, const String<C>& b)
	{
		return String<C>(a) + b;
	}

【23.4.6.3:　テンプレート関数の引数導出】

日付：　2016.09.09
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	ネストされたテンプレート型メンバに関して（？）、テンプレート引数が導出されない

	テンプレート関数の定義：
	
	template<typename T, typename A>
	typename List<T,A>::Iterator
	find(typename List<T,A>::Iterator b, typename List<T,A>::Iterator e, T v)
	{
		・・・
	}

	利用者コード：
	
	void fct(List<int, My_allocator>::Iterator b, List<int, My_allocator>::Iterator e)
	{
		auto p = find(b,e,17);
		//ここで、以下のエラーが出る
		// error: no matching function for call to 'find(List<int, My_allocator>::Iterator&, List<int, My_allocator>::Iterator&, int)'
		// note:   couldn't deduce template parameter 'A'
		・・・
	}
	
	findテンプレート関数呼び出しにおいて、テンプレート引数を明示的に指示すると
	うまくいく
	
	auto p = find<int,My_allocator>(b,e,17);

【23.4.7:　テンプレート関数のフレンド宣言】

日付：　2016.09.13
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
参考：https://docs.oracle.com/cd/E19205-01/820-1213/bkafz/index.html
コメント：
	テンプレートクラス内で、テンプレート関数をフレンド宣言をするとき、
	それに先立ってテンプレート宣言を行う必要がある
	
	template<typename T>
	class Matrix;

	template<typename T>
	class Vector {
		T v[rc_max];
	public:
		Vector();
		Vector(initializer_list<T>);
		Vector& operator=(initializer_list<T>);

		friend Vector operator* <>(const Matrix<T>&, const Vector&);
			// error: declaration of 'operator*' as non-function
	};

	↓
	
	template<typename T>
	class Matrix;

	template<typename T>
	class Vector;

	//　テンプレート関数の宣言をあらかじめ与えておく
	template<typename T>
	Vector<T> operator*(const Matrix<T>&, const Vector<T>&);

	template<typename T>
	class Vector {
		T v[rc_max];
	public:
		Vector();
		Vector(initializer_list<T>);
		Vector& operator=(initializer_list<T>);

		friend Vector operator* <>(const Matrix<T>&, const Vector&);
			// error: declaration of 'operator*' as non-function
	};



【25.2.2.:　値実引数にstringオブジェクトを指定できない】

日付：　2016.09.13
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	値実引数にstringをオブジェクトを指定できない

	Vec<string,""> c2;
	// error: 'class std::__cxx11::basic_string<char>' is not a valid type for a template non-type parameter



【25.2.3.:　lambda関数にconstを指定できない】

日付：　2016.09.18
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	lambda関数にconstを指定するとコンパイルエラーとなる

	auto cmp = [](const string& x, const string& y) const { return x<y; };
		// error: expected '{' before 'const'
		↓
	auto cmp = [](const string& x, const string& y) { return x<y; };


【25.2.5.:　完全特殊化されたテンプレートのメンバ関数を外部で定義】

日付：　2016.09.19、2016.09.22
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	完全特殊化されたテンプレートのメンバ関数を外部で定義するとき、
	宣言の先頭に　template<> をつけるとコンパイルエラーとなる
	template<> を外すと正しくコンパイルできる
	但し、この場合テンプレート関数扱いされないため、明示的にinlineを
	つける必要がある	
	
	template<>
	Vector<void*>::Vector() : v{nullptr}, sz{0} { ...
		// error: template-id 'Vector<>' for 'Vector<void*>::Vector()' does not match any template declaration
		↓
	inline Vector<void*>::Vector() : v{nullptr}, sz{0} { ...


【25.3.4.1:　sort関数内のless関数のバインド】

日付：　2016.09.22、2016.09.24
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
（2016.09.24:追記）

	下記の現象は、lessオーバーロード関数が、組み込み型引数のみをとるために
	ADL（実引数依存探索）が効かないため、テンプレート定義内の依存名が
	テンプレート定義時点のスコープに従って解決されることによる
	（「26.3.5:テンプレートと名前空間」を参照）
	
(2016.09.22の元々のコメント）

	sortテンプレート関数のヘッダを読み込む前に、lessオーバーロード関数を
	宣言しないと、一次lessテンプレート関数にバインドされてしまう
	
	#include "sort.h"
		// この中で、一般のlessテンプレート関数とsortテンプレート関数を定義
	
	bool less(const char* a, const char* b)
	{
		return strcmp(a,b)<0;
	}
	
	void overload()
	{
		Vector<int> vi{10,2,20,5,2,2,4};
		Vector<const char*> vcc{"this", "is", "a", "const", "char*", "Vector"};
		
		sort(vi);
		std::cout << "vi: " << vi << '\n';
		sort(vcc);	// ここで、一般のlessテンプレート関数がバインドされている
					//　文字列のソートが正しくできない。
		std::cout << "vcc: " << vcc << '\n';
	}

	lessオーバーロード関数定義と、sort.hのインクルードの順番を
	逆にすると問題が解決される
	
	つまり、sort内のless呼び出し箇所が、テンプレート引数への
	依存名と解釈されていない？
	
	template<typename T>
	void sort(Vector<T>& v)
	{
		const size_t n = v.size();

		for (int gap=n/2; 0<gap; gap/=2)
			for (int i=gap; i!=n; ++i)
				for (int j=i-gap; 0<=j; j-=gap)
					if (less(v[j+gap],v[j]))	//　ここがTに依存しない？
						swap(v[j],v[j+gap]);
	}


【27.4.1:　基底クラスの基底クラスとして派生クラスの関連型を指定できない】

日付：　2016.10.01
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：
	基底クラス（Node_base）の基底クラスとして派生クラス（Node_search）の
	関連型（balance_type）を指定すると、コンパイルエラーとなる

	template<typename N>
	struct Node_base : N::balance_type {
		↓
	error: no type named 'balance_type' in 'struct Search_node<double, Red_black_balance>'


【27.2.1.1:　テンプレート別名が全てのパターンでエラーとなる】

日付：　2016.10.04、2016.10.05
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキストの記述と異なり、conditional内のテンプレート別名が全てのパターンで
	エラーとなる
	
	struct Error { };

	// (1)original
	template<typename T>
	using Make_unsigned_for_integral = typename conditional<
			is_integral<T>::value,
			typename make_unsigned<T>::type,
			Error
		>::type;

	Make_unsigned_for_integral<int> u1;
	//Make_unsigned_for_integral<string> s1;
		// required by substitution of 'template<class T> using Make_unsigned_for_integral = typename std::conditional<std::is_integral<_Tp>::value, typename std::make_unsigned<_Tp>::type, void>::type [with T = std::__cxx11::basic_string<char>]'

	// (2)template alias
	template<typename T>
	using Make_unsigned = typename make_unsigned<T>::type;

	template<typename T>
	using Make_unsigned_for_integral2 = typename conditional<
			is_integral<T>::value,
			Make_unsigned<T>,
			Error
		>::type;

	Make_unsigned_for_integral2<int> u2;
	//Make_unsigned_for_integral2<string> s2;
		// required by substitution of 'template<class T> using Make_unsigned_for_integral2 = typename std::conditional<std::is_integral<_Tp>::value, typename std::make_unsigned<_Tp>::type, Error>::type [with T = std::__cxx11::basic_string<char>]'


	template<typename T>
	using Make_unsigned = typename make_unsigned<T>::type;

	template<template<typename...> class F, typename... Args>
	using Delay = F<Args...>;

	// (3)Delay evaluation
	template<typename T>
	using Make_unsigned_for_integral3 = typename conditional<
			is_integral<T>::value,
			Delay<Make_unsigned,T>,
			Error
		>::type;

	Make_unsigned_for_integral3<int> u3;
	//Make_unsigned_for_integral3<string> s3;
		// required by substitution of 'template<class T> using Make_unsigned_for_integral3 = typename std::conditional<std::is_integral<_Tp>::value, typename std::make_unsigned<_Tp>::type, Error>::type [with T = std::__cxx11::basic_string<char>]'


【27.2.2.2:　is_pod<T>()をテンプレート引数に使用してもエラーとならない】

日付：　2016.10.05
バージョン：　gcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.3.0
コメント：

	テキスト記述と異なり、is_pod<T>()をテンプレート引数に使用しても
	エラーとならない

	template<typename T>
	void do_something()
	{
		Conditional<(is_pod<T>()),On_heap<T>,Scoped<T>> x;
		cout << "typeid(x).name(): " << typeid(x).name() << '\n';
	}
